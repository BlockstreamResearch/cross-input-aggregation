<pre>
  Title: Half-Aggregation of BIP 340 signatures
</pre>

== Introduction ==

=== Abstract ===

This document describes ''half-aggregation'' of BIP 340 signatures.
Half-aggregation is a process for aggregating a collection of signatures into a single aggregate signature.
The size of the resulting aggregate signature is approximately half of the combined size of the original signatures.

=== Copyright ===

This document is licensed under the 3-clause BSD license.

=== Motivation ===

Half-aggregation is applicable if there is a verifier that needs to verify multiple signatures.
Instead of sending individual signatures to the verifier, the signatures can be compressed into a single aggregate signature and sent to the verifier.
If the verifier can successfully verify the aggregate signature, the verifier can be sure that the individual signatures would have passed verification.

The purpose of half-aggregation is to reduce the size of the data that is sent to the verifier.
While ''n'' BIP 340 signatures are ''64*n'' bytes, a half-aggregate of the same signatures is ''32*n + 32'' bytes.
The process of half-aggregation is straightforward: it is a pure function of the input signatures, public keys, and messages.
It is non-interactive and does ''not'' require cooperation from other parties, including signers or verifiers.

There are a variety of scenarios where half-aggregation of BIP-340 signatures is useful.
To keep this section brief and avoid getting outdated quickly, we focus on listing example applications and defer the detailed discussion of the application-specific trade-offs to other places.

One example is the Lightning Network routing gossip protocol, which [https://github.com/lightning/bolts/blob/2e8f2095a36afb9de38da0f3f0051c7dc16dfc36/07-routing-gossip.md as of this writing] involves messages that contain ECDSA signatures.
If the signature scheme was changed to BIP 340, half-aggregation could reduce the total amount of gossiped data.
Instead of sending individual gossip messages, nodes could assemble a batch of messages and half-aggregate the signatures of the individual messages into a single signature for the batch.

Another application of half-aggregation is within the Bitcoin consensus protocol.
In particular, it has been discussed in the context of the [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015700.html Graftroot proposal].
Half-aggregation would allow Graftroot spending to be as efficient as best-case Taproot spends by aggregating the signature of the ''surrogate script'' and signatures that satisfy this script.
Moreover, half-aggregation improves the efficiency of proposed Bitcoin script opcodes that verify multiple signatures, such as [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-February/019926.html OP_EVICT].

Half-aggregation can also be applied to the signatures in the inputs of Bitcoin transactions, a process known as cross-input signature aggregation (CISA).
This [https://github.com/ElementsProject/cross-input-aggregation/blob/master/savings.org reduces the size of an average transaction] by 20.6% and the weight by 7.6%.
A known downside of using half aggregation is that some uses of adaptor signature protocols [https://github.com/ElementsProject/cross-input-aggregation#half-aggregation-and-adaptor-signatures may be incompatible].
Usually, CISA is proposed with interactive ''full'' signature aggregation instead of non-interactive half-aggregation because creating a valid transaction already requires cooperation, and full signature aggregation is more efficient.
However, the difference in complexity between half-aggregation and full aggregation is so significant that basing a CISA on half-aggregation is a legitimate approach.

The most invasive application to Bitcoin's consensus would be block-wide signature aggregation.
It refers to a process where block producers aggregate as many transaction signatures as possible.
In the best case, a full block would only have a single half-aggregate signature.
While this is attractive from the efficiency perspective, block-wide aggregation requires more research (and, in particular, special attention to handling
[https://github.com/ElementsProject/cross-input-aggregation#half-aggregation-and-reorgs reorgs]).

=== Design ===

The idea for half-aggregation of Schnorr signatures was brought up in the context of block-wide signature aggregation [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014272.html by Tadge Dryja on the Bitcoin mailing list] in 2017.
The scheme had a security flaw that was [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014306.html noticed] and [https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-May/014308.html fixed] shortly after by Russell O'Connor and Andrew Poelstra.
In 2021 [https://eprint.iacr.org/2021/350 Chalkias, Garillot, Kondi and Nikolaenko] published a security proof in the random oracle model (ROM) that reduces the security of half-aggregation to the security of Schnorr signatures.
[https://eprint.iacr.org/2022/222.pdf Chen and Zhao] were able to produce a tight proof in the ROM and algebraic group model in the following year.
Moreover, they came up with an elegant approach to incremental aggregation that is used in this document.

* Incremental aggregation allows non-interactively aggregating additional BIP 340 signatures into an existing half-aggregate signature.
* A half-aggregate signature of ''u'' BIP 340 input signatures is serialized as the ''(u+1)⋅32''-byte array ''r<sub>1</sub> || ... || r<sub>u</sub> || bytes(s)'' where ''r<sub>i</sub>'' is a 32-byte array from input signature ''i'' and ''s'' is a scalar aggregate (see below for details).
* This document does ''not'' specify the aggregation of multiple aggregate signatures (yet). It is possible, but requires changing the encoding of an aggregate signature. Since it is not possible to undo the aggregation of the s-values, when verifying of such an aggregate signature the randomizers need to be the same as when verifying the individual aggregate signature. Therefore, the aggregate signature needs encode a tree that reveals how the individual signatures were aggregated and how the resulting aggregate signatures were reaggregated.
* There is a possible optimization where the first randomizer ''z<sub>0</sub>'' is set to the constant ''1'' which speeds up verification because ''z<sub>0</sub>⋅R<sub>0</sub> = R<sub>0</sub>''. This specification does not make use of this optimization yet (TODO).

== Description ==

=== Notation ===

See [https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki|BIP340].

=== Specification ===

==== Aggregate ====

''Aggregate'' takes an array of public key, message and signature triples and returns an aggregate signature.
If for every triple ''(p, m, s)'' we have that ''Verify(p, m, s)'' (as defined in BIP 340) returns true, then the returned aggregate signature and the array of ''(p, m)'' tuples passes ''VerifyAggregate''.

Input:
* ''pms<sub>0..u-1</sub>'': an array of ''u'' triples, where the first element of each triple is a 32-byte public key, the second element is a 32-byte message and the third element is a 64-byte BIP 340 signature

'''''Aggregate(pms<sub>0..u-1</sub>)''''':
* Let ''aggsig = bytes(0)''
* Return ''IncAggregate(aggsig, pms<sub>0..u-1</sub>)''; fail if that fails.

=== IncAggregate ===

''IncAggregate'' takes an aggregate signature, an array of public key and message tuples corresponding to the aggregate signature, and an additional array of public key, message and signature triples.
It aggregates the additional array of triples into the existing aggregate signature and returns the resulting new aggregate signature.
In other words, if ''VerifyAggregate(aggsig, pm_aggd)'' passes and for every triple ''(p, m, s)'' in ''pms_to_agg'' we have that ''Verify(p, m, s)'' (as defined in BIP 340) returns true, then the returned aggregate signature along with the array of ''(p, m)'' tuples of ''pm_aggd'' and ''pms_to_agg'' passes ''VerifyAggregate''.

Input:
* ''aggsig'' : a byte array
* ''pm_aggd<sub>0..v-1</sub>'': an array of ''v'' tuples, where the first element of each tuple is a 32-byte public key and the second element is a 32-byte message
* ''pms_to_agg<sub>0..u-1</sub>'': an array of ''u'' triples, where the first element of each tuple is a 32-byte public key, the second element is a 32-byte message and the third element is a 64-byte BIP 340 signature

'''''IncAggregate(aggsig, pm_aggd<sub>0..v-1</sub>, pms_to_agg<sub>0..u-1</sub>)''''':
* Fail if ''len(aggsig) &ne; 32 * (v + 1)''
* For ''i = 0 .. v-1'':
** Let ''(pk<sub>i</sub>, m<sub>i</sub>) = pm_aggd<sub>i</sub>''
** Let ''r<sub>i</sub> = aggsig[i⋅32:(i+1)⋅32]''
* For ''i = v .. v+u-1'':
** Let ''(pk<sub>i</sub>, m<sub>i</sub>, sig<sub>i</sub>) = pms_to_agg<sub>i-v</sub>''
** Let ''r<sub>i</sub> = sig<sub>i</sub>[0:32]''
** Let ''s<sub>i</sub> = int(sig<sub>i</sub>[32:64])''
** Let ''z<sub>i</sub> = int(hash<sub>HalfAgg/randomizer</sub>(r<sub>0</sub> || pk<sub>0</sub> || m<sub>0</sub> || ... || r<sub>i</sub> || pk<sub>i</sub> || m<sub>i</sub>)) mod n''
* Let ''s = int(aggsig[(v⋅32:(v+1)⋅32]) + z<sub>v</sub>⋅s<sub>v</sub> + ... + z<sub>v+u-1</sub>⋅s<sub>v+u-1</sub> mod n''
* Return ''r<sub>0</sub> || ... || r<sub>v+u-1</sub> || bytes(s)''

==== VerifyAggregate ====

''VerifyAggregate'' verifies a given aggregate signature against an array of public key and message tuples.

Input:
* ''aggsig'' : a byte array
* ''pm_aggd<sub>0..u-1</sub>'': an array of ''u'' tuples, where the first element of each tuple is a 32-byte public key and the second element is a 32-byte message

'''''VerifyAggregate(aggsig, pm_aggd<sub>0..u-1</sub>)''''':
* Fail if ''len(aggsig) &ne; 32 * (u + 1)''
* For ''i = 0 .. u-1'':
** Let ''(pk<sub>i</sub>, m<sub>i</sub>) = pm_aggd<sub>i</sub>''
** Let ''P<sub>i</sub> = lift_x(int(pk<sub>i</sub>))''; fail if that fails
** Let ''r<sub>i</sub> = aggsig[i⋅32:(i+1)⋅32]''
** Let ''R<sub>i</sub> = lift_x(int(r<sub>i</sub>))''; fail if that fails
** Let ''e<sub>i</sub> = int(hash<sub>BIP0340/challenge</sub>(bytes(r<sub>i</sub>) || pk<sub>i</sub> || m<sub>i</sub>)) mod n''
** Let ''z<sub>i</sub> = int(hash<sub>HalfAgg/randomizer</sub>(r<sub>0</sub> || pk<sub>0</sub> || m<sub>0</sub> || ... || r<sub>i</sub> || pk<sub>i</sub> || m<sub>i</sub>)) mod n''
* Let ''s = int(sig[u⋅32:(u+1)⋅32]); fail if ''s &ge; p''
* Fail if ''s⋅G &ne; z<sub>0</sub>⋅(R<sub>0</sub> + e<sub>0</sub>⋅P<sub>0</sub>) + ... + z<sub>u-1</sub>⋅(R<sub>u-1</sub> + e<sub>u-1</sub>⋅P<sub>u-1</sub>)''
* Return success iff no failure occurred before reaching this point.

The verification algorithm is similar to [https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki#batch-verification BIP340 Batch Verification]. As in BIP340, using an [https://bitcoin.stackexchange.com/a/80702/109853 efficient algorithm for computing the sum of multiple EC multiplications] can significantly speed up verification.

=== Test Vectors and Reference Code ===
